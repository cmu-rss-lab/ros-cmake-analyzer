from __future__ import annotations

import abc
import enum
import re
import typing as t
from dataclasses import dataclass
from pathlib import Path

from loguru import logger

from .cmake.parser import ParserContext
from .cmake.parser import argparse as cmake_argparse
from .core.nodelets_xml import NodeletsInfo
from .core.package import Package
from .utils import key_val_list_to_dict

__all__ = ("CMakeExtractor", "CMakeInfo", "cmake_command")


DUMMY_VALUE = "__dummy_property_value__"  # A dummy value used as a stand in for properties we don't need


class SourceLanguage(enum.Enum):
    CXX = "cxx"
    PYTHON = "python"


@dataclass(frozen=True)
class CMakeTarget:
    name: str
    language: SourceLanguage
    sources: set[Path]
    restrict_to_paths: set[Path]
    cmakelists_file: str
    cmakelists_line: int

    def to_dict(self) -> dict[str, t.Any]:
        return {
            "name": self.name,
            "language": self.language.value,
            "sources": list(self.sources),
            "path_restrictions": list(self.restrict_to_paths),
            "cmakelists_file": self.cmakelists_file,
            "cmakelists_line": self.cmakelists_line,
        }

    @classmethod
    def from_dict(cls, info: dict[str, t.Any]) -> CMakeTarget:
        return CMakeTarget(
            info["name"],
            SourceLanguage(info["language"]),
            set(info["sources"]),
            set(info["path_restrictions"]),
            info["cmakelists_file"],
            info["cmakelists_line"],
        )


@dataclass(frozen=True)
class CMakeBinaryTarget(CMakeTarget):
    _entrypoint: str | None = None

    @property
    def entrypoint(self) -> str | None:
        if self.language == SourceLanguage.CXX:
            return "main"
        return None

    def to_dict(self) -> dict[str, t.Any]:
        d = super().to_dict()
        if self.entrypoint:
            d["entrypoint"] = self.entrypoint
        return d

    @classmethod
    def from_dict(cls, info: dict[str, t.Any]) -> CMakeBinaryTarget:
        return CMakeBinaryTarget(info["name"],
                                 SourceLanguage(info["language"]),
                                 set(info["sources"]),
                                 set(info["path_restrictions"]),
                                 info["cmakelists_file"],
                                 info["cmakelists_line"],
                                 info.get("entrypoint", None))


@dataclass(frozen=True)
class CMakeLibraryTarget(CMakeBinaryTarget):
    _entrypoint: str


@dataclass(frozen=True)
class IncompleteCMakeLibraryTarget(CMakeTarget):

    def complete(self, entrypoint: str) -> CMakeLibraryTarget:
        return CMakeLibraryTarget(name=self.name,
                                  language=self.language,
                                  sources=self.sources,
                                  restrict_to_paths=self.restrict_to_paths,
                                  cmakelists_file=self.cmakelists_file,
                                  cmakelists_line=self.cmakelists_line,
                                  _entrypoint=entrypoint)


@dataclass(frozen=True)
class CMakeInfo:
    """Summarizes the source generating parts of a CMakeFile.

    Attributes
    ----------
    targets: Dict[str, CMakeTarget]
        A mapping of nodes or nodelets to the CMakeTarget that contains the source code for them.
    generated_sources: Collection[str]
        A collection of sources that were generated by targets in the CMakeLists file.

    """

    targets: dict[str, CMakeTarget]
    generated_sources: t.Collection[str]


@dataclass(frozen=True)
class NodeletLibrary:
    """Represents a piece of information found in the nodelet_plygin.xml file.

    path: str
        The path to the library containing the nodelet
    name: str
        The class name of the main entrypoint for the nodelet
    tupe_: str
        The type of the class
    """

    path: str
    name: str
    type_: str

    @property
    def entrypoint(self) -> str:
        return self.type_ + "::onInit"


class CommandHandlerType(type, abc.ABC):
    def __init__(cls, name: str, bases: t.Any, attrs: dict[str, t.Any]):
        cls._handlers = {}
        for name, method in attrs.items():
            if hasattr(method, "command"):
                if hasattr(method, "commands"):
                    for command in method.commands:
                        cls._handlers[command] = method
                else:
                    cls._handlers[name] = method


def cmake_command(arg: t.Callable[[dict[str, t.Any], list[str]], None] | list[str]) -> t.Callable[[dict[str, t.Any], list[str]], None]:
    if callable(arg):
        arg.command = True
        return arg

    def c2(fn: t.Callable[[dict[str, t.Any], list[str]], None]) -> t.Callable[[dict[str, t.Any], list[str]], None]:
        fn.command = True
        fn.commands = arg
        return fn
    return c2


class CMakeExtractor(metaclass=CommandHandlerType):

    _files_generated_by_cmake: t.ClassVar[set[str]] = set()

    def __init__(self, package_dir: str | Path) -> None:
        package_path = Path(package_dir) if isinstance(package_dir, str) else package_dir
        self.package = Package.from_dir(package_path)

    def command_for(self, command: str) -> t.Callable[[dict[str, t.Any], list[str]], None] | None:
        for h in type(self).__mro__:
            if hasattr(h, "_handlers") and command in h._handlers:
                return h._handlers[command]
        return None

    @abc.abstractmethod
    def package_paths(self) -> set[Path]:
        ...

    @abc.abstractmethod
    def get_cmake_info(self) -> CMakeInfo:
        ...

    @abc.abstractmethod
    def _get_global_cmake_variables(self) -> dict[str, str]:
        ...

    def get_nodelet_entrypoints(self) -> t.Mapping[str, NodeletLibrary]:
        """Returns the potential nodelet entrypoints and classname for the package.

        Parameters
        ----------
        package: Package
            The package to get nodelet info from

        Returns
        -------
        Mapping[str, NodeletLibrary]
            A mapping of nodelet names to NodeletInfo

        """
        nodelets_xml_path = self.package.path / "nodelet_plugins.xml"
        if not nodelets_xml_path.exists():
            # Read from package
            defn = self.package.definition
            for export in defn.exports:
                logger.debug("Looking for export in pacakge.xml")
                if export.tagname == "nodelet" and "plugin" in export.attributes:
                    plugin = export.attributes["plugin"]
                    plugin = plugin.replace("${prefix}", "")
                    nodelets_xml_path = self.package.path / plugin
                    if nodelets_xml_path.exists():
                        logger.debug(f"Reading plugin information from {nodelets_xml_path!s}")
                        break
        if nodelets_xml_path.exists():
            logger.debug(f"Reading plugin information from {nodelets_xml_path}")
            with nodelets_xml_path.open("r") as f:
                contents = f.read()
            logger.debug(f"Contents of that file: {contents}")
            nodelet_info = NodeletsInfo.from_nodelet_xml(contents)
            # If the name is of the form package/nodelet then just return it keyed by nodelete
            # otherwise key by the full name
            entrypoints = {info.name.split("/")[1]: info for info in nodelet_info.libraries if "/" in info.name}
            entrypoints.update({info.name: info for info in nodelet_info.libraries if "/" not in info.name})
            return entrypoints
        return {}

    def _info_from_cmakelists(self) -> CMakeInfo:
        with (self.package.path / "CMakelists.txt").open() as f:
            contents = "".join(f.readlines())
        env: dict[str, str] = {"cmakelists": "CMakeLists.txt"}
        info = self._process_cmake_contents(contents, env)
        nodelet_libraries = self.get_nodelet_entrypoints()
        # Add in classname as a name that can be referenced in loading nodelets
        for nodelet, library in nodelet_libraries.items():
            if nodelet in info.targets:
                info.targets[library.name] = info.targets[nodelet]
            else:
                # This is a hack. What really needs to be done is to look through all
                # the source files in info.targets to find which info.target defines the
                # class in library.name or library.type, then add that target keyed by
                # the type as well. This is needed because nodelets can be loaded into
                # managers by their class name.
                # TODO: Fix post paper
                potential_matches = [key for key in info.targets if key in library.path or key in library.name]
                if potential_matches:
                    info.targets[library.name.split("/")[-1]] = info.targets[potential_matches[0].split("/")[-1]]

        for nodelet, library in nodelet_libraries.items():
            if nodelet not in info.targets:
                logger.warning(f"info.targets={info.targets}")
                logger.warning(f"Package {self.package.name}: '{nodelet}' "
                               f"is referenced in nodelet_plugins.xml but not in "
                               f"CMakeLists.txt.")
            else:
                target = info.targets[nodelet]
                if isinstance(target, IncompleteCMakeLibraryTarget):
                    info.targets[nodelet] = target.complete(entrypoint=library.entrypoint)
                else:
                    logger.warning(f"'{nodelet} target '{target.name}' "
                                   f"trying to set entrypoint on {type(target)}'")
        return info

    def _cmake_argparse(self, args, opts):   # noqa: ANN202, ANN001
        return cmake_argparse(args, opts)

    def _process_cmake_contents(
            self,
            file_contents: str,
            cmake_env: dict[str, str],
    ) -> CMakeInfo:
        """Processes the contents of a CMakeLists.txt file.

        Adds information about executables. Recursively includes
        other CMakeLists.txt files that may be included.

        Parameters
        ----------
        file_contents: str
            The contents of the CMakeLists.txt file
        package: Package
            The package where the CMakeLists.txt file is defined
        cmake_env: t.Dict[str, str]
            Any context variables for processing the contents

        Returns
        -------
        CMakeInfo:
            Information about the targets in CMakeLists.txt

        """
        context = ParserContext().parse(file_contents, skip_callable=False, var=cmake_env)
        self.executables = {}
        for cmd, raw_args, _arg_tokens, (_fname, line, _column) in context:
            cmake_env["cmakelists_line"] = line
            try:
                cmd = cmd.lower()    # noqa: PLW2901
                command = self.command_for(cmd)
                if command:
                    command(self, cmake_env, raw_args)
            except Exception:
                logger.error(f"Error processing {cmd}({raw_args}) in "
                             f"{cmake_env['cmakelists'] if 'cmakelists' in cmake_env else 'unknown'}")
                raise
        return CMakeInfo(self.executables, self._files_generated_by_cmake)

    @cmake_command
    def project(self, cmake_env: dict[str, t.Any], raw_args: list[str]) -> None:
        opts, args = self._cmake_argparse(raw_args, {})
        cmake_env["PROJECT_NAME"] = args[0]
        logger.info(f"Setting PROJECT_NAME={args[0]}")

    @cmake_command
    def set_target_properties(self, cmake_env: dict[str, t.Any], raw_args: list[str]) -> None:
        opts, args = self._cmake_argparse(raw_args, {"PROPERTIES": "*"})
        properties = key_val_list_to_dict(opts.get("PROPERTIES", []))
        if "OUTPUT_NAME" in properties:
            var_pattern = re.compile(r"([^$]*)\${([^}]*)}(.*)")
            var_match = var_pattern.match(args[0])
            if var_match:
                args[0] = var_match.group(1) + cmake_env[var_match.group(2)] + var_match.group(3)
            if args[0] in self.executables:
                self.executables[properties["OUTPUT_NAME"]] = self.executables[args[0]]
                del self.executables[args[0]]
            else:
                logger.error(f"{args[0]} is not in the list of targets")

    @cmake_command
    def set(self, cmake_env: dict[str, t.Any], raw_args: list[str]) -> None:
        opts, args = self._cmake_argparse(
            raw_args,
            {"PARENT_SCOPE": "-", "FORCE": "-", "CACHE": "*"},
        )
        cmake_env[args[0]] = ";".join(args[1:])

    @cmake_command
    def unset(self, cmake_env: dict[str, t.Any], raw_args: list[str]) -> None:
        opts, args = self._cmake_argparse(raw_args, {"CACHE": "-"})
        cmake_env[args[0]] = ""

    @cmake_command
    def aux_source_directory(
            self,
            cmake_env: dict[str, t.Any],
            raw_args: list[str],
    ) -> None:
        # aux_source_directory(<dir> <var>)
        # Collects the names of all the source files in the specified directory and
        # stores the list in the <variable>
        # https://cmake.org/cmake/help/latest/command/aux_source_directory.html
        var_name = raw_args[1]
        dir_name = Path(raw_args[0])
        path = self.package.path / cmake_env["cwd"] / dir_name if "cwd" in cmake_env else self.package.path / dir_name
        values = ";".join(str(dir_name / f) for f in path.glob("*"))
        cmake_env[var_name] = values

    @cmake_command(["list"])
    def list_directive(
            self,
            cmake_env: dict[str, t.Any],
            raw_args: list[str],
    ) -> None:
        logger.info(f"Processing list directive: {raw_args}")
        opts, args = self._cmake_argparse(raw_args, {"APPEND": "-"})
        if not opts["APPEND"]:
            logger.warning(f"Cannot process list({args[0]} ...)")
            return
        append_to = cmake_env[args[0]]
        if not append_to:
            cmake_env[args[0]] = []
            append_to = cmake_env[args[0]]
        if isinstance(append_to, str):
            if append_to:
                append_to += f";{args[1]}"
            else:
                append_to = args[1]
            cmake_env[args[0]] = append_to
        elif isinstance(append_to, list):
            append_to.append(args[1])
        else:
            logger.error(f"Don't know how to append_to append append_to type: {type(append_to)}")

    @cmake_command
    def file(
            self,
            cmake_env: dict[str, t.Any],
            raw_args: list[str],
    ) -> None:
        logger.debug(f"Processing file directive: {raw_args}")
        opts, args = self._cmake_argparse(raw_args, {"FOLLOW_SYMLINKS": "-",
                                               "LIST_DIRECTORIES": "?",
                                               "RELATIVE": "?",
                                               "GLOB_RECURSE": "-",
                                               "GLOB": "-",
                                               })
        if not opts["GLOB_RECURSE"] and not opts["GLOB"]:
            logger.warning(f"Cannot process file({args[0]} ...")
            return
        path = self.package.path / cmake_env["cwd"] if "cwd" in cmake_env else self.package.path
        matches = []
        for arg in args[1:]:
            finds = [self._trim_and_unquote(str(f)) for f in path.rglob(arg)]
            logger.debug(f"Found the following matches to {arg} in {path}: {finds}")
            matches.extend(finds)
        if opts["RELATIVE"]:
            # convert path to be relative
            relative = self.package.path / opts["RELATIVE"]
            matches.extend([str((path / m).relative_to(relative)) for m in matches])
        cmake_env[args[0]] = ";".join(matches)
        logger.debug(f"Set {args[0]} to {cmake_env[args[0]]}")

    @cmake_command
    def __process_add_subdirectory(
            self,
            cmake_env: dict[str, str],
            raw_args: list[str],
    ) -> None:
        opts, args = self._cmake_argparse(
            raw_args,
            {"EXCLUDE_FROM_ALL": "-"},
        )
        if opts["EXCLUDE_FROM_ALL"]:
            return
        new_env = cmake_env.copy()
        new_env["cwd"] = str(Path(cmake_env.get("cwd", ".")) / args[0])
        new_env["PROJECT_SOURCE_DIR"] = str(Path(cmake_env.get("CMAKE_SOURCE_DIR", ".")) / args[0])
        new_env["CMAKE_CURRENT_SOURCE_DIR"] = new_env["cwd"]
        cmakelists_path = self.package.path / new_env["cwd"] / "CMakeLists.txt"
        new_env["cmakelists"] = str(cmakelists_path)
        logger.info(f"Processing {cmakelists_path!s}")
        with cmakelists_path.open() as f:
            contents = f.read()
        included_pacakge_instances = self._process_cmake_contents(contents, new_env)
        self.executables.update(
            **{s: included_pacakge_instances.targets[s] for s in included_pacakge_instances.targets})

    @cmake_command(["add_executable", "cuda_add_executable"])
    def add_executable(
            self,
            cmake_env: dict[str, t.Any],
            raw_args: list[str],
    ) -> None:
        opts, args = self._cmake_argparse(
            raw_args,
            {"EXCLUDE_FROM_ALL": "-"},
        )
        if opts["EXCLUDE_FROM_ALL"]:
            return
        name = args[0]
        sources: set[Path] = set()
        for source in args[1:]:
            real_src = self._resolve_to_real_file(source, self.package.path, cmake_env)
            if real_src:
                sources.add(real_src)
            else:
                logger.warning(f"'{source} did not resolve to a real file.")
        logger.debug(f"Adding C++ sources for {name}")
        self.executables[name] = CMakeBinaryTarget(
            name=name,
            language=SourceLanguage.CXX,
            sources=sources,
            restrict_to_paths=self.package_paths(),
            cmakelists_file=cmake_env["cmakelists"],
            cmakelists_line=cmake_env["cmakelists_line"],
        )

    @cmake_command(["add_library", "cuda_add_library"])
    def add_library(
            self,
            cmake_env: dict[str, t.Any],
            raw_args: list[str],
    ) -> None:
        opts, args = self._cmake_argparse(
            raw_args,
            {"SHARED": "-",
             "STATIC": "-",
             "MODULE": "-",
             "EXCLUDE_FROM_ALL": "-",
             },
        )
        if opts["EXCLUDE_FROM_ALL"]:
            return
        name = args[0]
        sources: set[Path] = set()
        for source in args[1:]:
            real_src = self._resolve_to_real_file(source, self.package.path, cmake_env)
            if real_src:
                sources.add(real_src)
        logger.debug(f"Adding C++ library {name}")
        self.executables[name] = IncompleteCMakeLibraryTarget(
            name,
            SourceLanguage.CXX,
            sources,
            self.package_paths(),
            cmakelists_file=cmake_env["cmakelists"],
            cmakelists_line=cmake_env["cmakelists_line"],
        )

    @cmake_command
    def configure_file(
            self,
            cmake_env: dict[str, t.Any],
            rawargs: list[str],
    ) -> None:
        _opts, args = self._cmake_argparse(rawargs, {"NO_SOURCE_PERMISSIONS": "-",
                                               "USE_SOURCE_PERMISSIONS": "-",
                                               "COPY_ONLY": "-",
                                               "ESCAPE_QUOTES": "-",
                                               "@ONLY": "-",
                                               "NEWLINE_STYLE": "?",
                                               "FILE_PERMISSIONS": "?"})
        # Writing to the container doesn't persist, and so generated sources
        # aren't able to be included. Put this in a list so that we can remember them
        # and not try to resolve them to real files
        if len(args) > 0:
            # Ret rid of the parameter and just use the files
            args = args[1:]
        if len(args) > 0:
            self._files_generated_by_cmake.union(args)
        else:
            # We warn because we ignore generated files
            logger.warning(f"'{cmake_env['cmakelists']}' has no target for 'configure_fle({rawargs})")

    def _trim_and_unquote(self, s: str) -> str:
        s = s.strip()
        is_single_quoted = s.startswith("'") and s.endswith("'")
        is_double_quoted = s.startswith('"') and s.endswith('"')
        if is_single_quoted or is_double_quoted:
            s = s[1:-1]
        return s

    def _resolve_to_real_file(
            self,
            filename: str,
            package: Path,
            cmake_env: dict[str, str],
    ) -> Path | None:
        if filename in self._files_generated_by_cmake:
            return None
        real_filename = Path(filename)
        if "cwd" in cmake_env:
            real_filename = Path(cmake_env["cwd"]) / filename
        if not (package / real_filename).is_file():
            parent = real_filename.parent
            try:
                all_files = (package / parent).glob("*")
                matching_files = [f for f in all_files if str(f).startswith(str(real_filename))]
                if len(matching_files) != 1:
                    raise ValueError(f"Only one file should match '{real_filename!s}'. "  # noqa: TRY301
                                     f"Currently {len(matching_files)} files do: {matching_files}")
                real_filename = parent / matching_files[0]
            except ValueError:
                raise
            except Exception:
                logger.error(
                    f"Error finding real file matching {real_filename} "
                    f"in {package / parent!s}")
                logger.error(cmake_env)
                raise
        return real_filename
