from __future__ import annotations

import abc
import enum
import re
import typing as t
from dataclasses import dataclass, field
from pathlib import Path

from cmake.parser import ParserContext
from cmake.parser import argparse as cmake_argparse
from core.nodelets_xml import NodeletsInfo
from loguru import logger
from utils import key_val_list_to_dict

if t.TYPE_CHECKING:
    from core.package import Package

DUMMY_VALUE = "__dummy_property_value__"  # A dummy value used as a stand in for properties we don't need


class SourceLanguage(enum.Enum):
    CXX = "cxx"
    PYTHON = "python"


@dataclass(frozen=True)
class CMakeTarget:
    name: str
    language: SourceLanguage
    sources: set[str]
    restrict_to_paths: set[str]
    cmakelists_file: str
    cmakelists_line: int

    def to_dict(self) -> dict[str, t.Any]:
        return {
            "name": self.name,
            "language": self.language.value,
            "sources": list(self.sources),
            "path_restrictions": list(self.restrict_to_paths),
            "cmakelists_file": self.cmakelists_file,
            "cmakelists_line": self.cmakelists_line,
        }

    @classmethod
    def from_dict(cls, info: dict[str, t.Any]) -> CMakeTarget:
        return CMakeTarget(
            info["name"],
            SourceLanguage(info["language"]),
            set(info["sources"]),
            set(info["path_restrictions"]),
            info["cmakelists_file"],
            info["cmakelists_line"],
        )


@dataclass(frozen=True)
class CMakeBinaryTarget(CMakeTarget):
    _entrypoint: str | None = None

    @property
    def entrypoint(self) -> str | None:
        if self.language == SourceLanguage.CXX:
            return "main"
        return None


@dataclass(frozen=True)
class CMakeLibraryTarget(CMakeBinaryTarget):
    # TODO: This is a hack to allow the entrypoint to be set later
    _entrypoint: set[str] = field(default_factory=set)  # This is a hack to allow this field to be set later

    @property
    def entrypoint(self) -> str | None:
        if len(self._entrypoint) == 1:
            return next(iter(self._entrypoint))
        return None

    def add_entrypoint(self, entrypoint: str) -> None:
        self._entrypoint.add(entrypoint)

    def to_dict(self) -> dict[str, t.Any]:
        d = super().to_dict()
        if self.entrypoint:
            d["entrypoint"] = self.entrypoint
        return d

    @classmethod
    def from_dict(cls, info: dict[str, t.Any]) -> CMakeLibraryTarget:
        return CMakeLibraryTarget(info["name"],
                                  SourceLanguage(info["language"]),
                                  set(info["sources"]),
                                  set(info["path_restrictions"]),
                                  info["cmakelists_file"],
                                  info["cmakelists_line"],
                                  info.get("entrypoint", None),
                                  )


@dataclass(frozen=True)
class CMakeInfo:
    """Summarizes the source generating parts of a CMakeFile.

    Attributes
    ----------
    targets: Dict[str, CMakeTarget]
        A mapping of nodes or nodelets to the CMakeTarget that contains the source code for them.
    generated_sources: Collection[str]
        A collection of sources that were generated by targets in the CMakeLists file.

    """

    targets: dict[str, CMakeTarget]
    generated_sources: t.Collection[str]


@dataclass(frozen=True)
class NodeletLibrary:
    """Represents a piece of information found in the nodelet_plygin.xml file.

    path: str
        The path to the library containing the nodelet
    name: str
        The class name of the main entrypoint for the nodelet
    tupe_: str
        The type of the class
    """

    path: str
    name: str
    type_: str

    @property
    def entrypoint(self) -> str:
        return self.type_ + "::onInit"


class CMakeExtractor(abc.ABC):
    _files_generated_by_cmake: set[str] = set()

    @abc.abstractmethod
    def package_paths(self, package: Package) -> set[str]:
        ...

    @abc.abstractmethod
    def get_cmake_info(self, package: Package) -> CMakeInfo:
        ...

    @abc.abstractmethod
    def _get_global_cmake_variables(self, package: Package) -> dict[str, str]:
        ...

    def get_nodelet_entrypoints(self, package: Package) -> t.Mapping[str, NodeletLibrary]:
        """Returns the potential nodelet entrypoints and classname for the package.

        Parameters
        ----------
        package: Package
            The package to get nodelet info from

        Returns
        -------
        Mapping[str, NodeletLibrary]
            A mapping of nodelet names to NodeletInfo

        """
        nodelets_xml_path = package.path / "nodelet_plugins.xml"
        if not nodelets_xml_path.exists():
            # Read from package
            defn = package.definition
            for export in defn.exports:
                logger.debug("Looking for export in pacakge.xml")
                if export.tagname == "nodelet" and "plugin" in export.attributes:
                    plugin = export.attributes["plugin"]
                    plugin = plugin.replace("${prefix}", "")
                    nodelets_xml_path = package.path / plugin
                    if nodelets_xml_path.exists():
                        logger.debug(f"Reading plugin information from {nodelets_xml_path!s}")
                        break
        if nodelets_xml_path.exists():
            logger.debug(f"Reading plugin information from {nodelets_xml_path}")
            with nodelets_xml_path.open("r") as f:
                contents = f.read()
            logger.debug(f"Contents of that file: {contents}")
            nodelet_info = NodeletsInfo.from_nodelet_xml(contents)
            # If the name is of the form package/nodelet then just return it keyed by nodelete
            # otherwise key by the full name
            entrypoints = {info.name.split("/")[1]: info for info in nodelet_info.libraries if "/" in info.name}
            entrypoints.update({info.name: info for info in nodelet_info.libraries if "/" not in info.name})
            return entrypoints
        return {}

    def _info_from_cmakelists(self, package: Package) -> CMakeInfo:
        with (package.path / "CMakelists.txt").open() as f:
            contents = "".join(f.readlines())
        env: dict[str, str] = {}
        info = self._process_cmake_contents(contents, package, env)
        nodelet_libraries = self.get_nodelet_entrypoints(package)
        # Add in classname as a name that can be referenced in loading nodelets
        for nodelet, library in nodelet_libraries.items():
            if nodelet in info.targets:
                info.targets[library.name] = info.targets[nodelet]
            else:
                # This is a hack. What really needs to be done is to look through all
                # the source files in info.targets to find which info.target defines the
                # class in library.name or library.type, then add that target keyed by
                # the type as well. This is needed because nodelets can be loaded into
                # managers by their class name.
                # TODO: Fix post paper
                potential_matches = [key for key in info.targets if key in library.path or key in library.name]
                if potential_matches:
                    info.targets[library.name.split("/")[-1]] = info.targets[potential_matches[0].split("/")[-1]]

        for nodelet, library in nodelet_libraries.items():
            if nodelet not in info.targets:
                logger.warning(f"info.targets={info.targets}")
                logger.warning(f"Package {package.name}: '{nodelet}' "
                               f"is referenced in nodelet_plugins.xml but not in "
                               f"CMakeLists.txt.")
            else:
                target = info.targets[nodelet]
                assert isinstance(target, CMakeLibraryTarget)
                target._entrypoint.add(library.entrypoint)
        return info

    def _process_cmake_contents(  # noqa: PLR0915
            self,
            file_contents: str,
            package: Package,
            cmake_env: dict[str, str],
    ) -> CMakeInfo:
        """Processes the contents of a CMakeLists.txt file.

        Adds information about executables. Recursively includes
        other CMakeLists.txt files that may be included.

        Parameters
        ----------
        file_contents: str
            The contents of the CMakeLists.txt file
        package: Package
            The package where the CMakeLists.txt file is defined
        cmake_env: t.Dict[str, str]
            Any context variables for processing the contents

        Returns
        -------
        CMakeInfo:
            Information about the targets in CMakeLists.txt

        """
        executables: dict[str, CMakeTarget] = {}
        context = ParserContext().parse(file_contents, skip_callable=False, var=cmake_env)
        for cmd, raw_args, _arg_tokens, (_fname, line, _column) in context:
            cmake_env["cmakelists_line"] = line
            try:
                cmd = cmd.lower()    # noqa: PLW2901
                if cmd == "project":
                    opts, args = cmake_argparse(raw_args, {})
                    cmake_env["PROJECT_NAME"] = args[0]
                    logger.info(f"Setting PROJECT_NAME={args[0]}")
                elif cmd == "configure_file":
                    self._process_configure_file(cmake_env, raw_args)
                elif cmd == "aux_source_directory":
                    self.__process_aux_source_directory(cmake_env, package, raw_args)
                elif cmd == "set_target_properties":
                    opts, args = cmake_argparse(raw_args, {"PROPERTIES": "*"})
                    properties = key_val_list_to_dict(opts.get("PROPERTIES", []))
                    if "OUTPUT_NAME" in properties:
                        var_pattern = re.compile(r"([^$]*)\${([^}]*)}(.*)")
                        var_match = var_pattern.match(args[0])
                        if var_match:
                            args[0] = var_match.group(1) + cmake_env[var_match.group(2)] + var_match.group(3)
                        if args[0] in executables:
                            executables[properties["OUTPUT_NAME"]] = executables[args[0]]
                            del executables[args[0]]
                        else:
                            logger.error(f"{args[0]} is not in the list of targets")
                elif cmd == "set":
                    opts, args = cmake_argparse(
                        raw_args,
                        {"PARENT_SCOPE": "-", "FORCE": "-", "CACHE": "*"},
                    )
                    cmake_env[args[0]] = ";".join(args[1:])
                elif cmd == "unset":
                    opts, args = cmake_argparse(raw_args, {"CACHE": "-"})
                    cmake_env[args[0]] = ""
                elif cmd == "file":
                    logger.debug(f"Processing file directive: {raw_args}")
                    opts, args = cmake_argparse(raw_args, {"FOLLOW_SYMLINKS": "-",
                                                           "LIST_DIRECTORIES": "?",
                                                           "RELATIVE": "?",
                                                           "GLOB_RECURSE": "-",
                                                           "GLOB": "-",
                                                           })
                    self.__process_file_directive(args, cmake_env, opts, package)
                elif cmd == "list":
                    logger.info(f"Processing list directive: {raw_args}")
                    opts, args = cmake_argparse(raw_args, {"APPEND": "-"})
                    self.__process_list_directive(args, cmake_env, opts)
                elif cmd in ("add_executable", "cuda_add_executable"):
                    opts, args = cmake_argparse(
                        raw_args,
                        {"EXCLUDE_FROM_ALL": "-"},
                    )
                    if not opts["EXCLUDE_FROM_ALL"]:
                        self.__process_add_executable(
                            args,
                            cmake_env,
                            executables,
                            package)
                elif cmd == "catkin_install_python":
                    self.__process_python_executables(
                        raw_args,
                        cmake_env,
                        executables,
                        package,
                    )
                elif cmd in ("add_library", "cuda_add_library"):
                    opts, args = cmake_argparse(
                        raw_args,
                        {"SHARED": "-",
                         "STATIC": "-",
                         "MODULE": "-",
                         "EXCLUDE_FROM_ALL": "-",
                         },
                    )
                    if not opts["EXCLUDE_FROM_ALL"]:
                        self.__process_add_library(
                            args,
                            cmake_env,
                            executables,
                            package)
                elif cmd == "add_subdirectory":
                    opts, args = cmake_argparse(
                        raw_args,
                        {"EXCLUDE_FROM_ALL": "-"},
                    )
                    if not opts["EXCLUDE_FROM_ALL"]:
                        executables = self.__process_add_subdirectory(
                            args,
                            cmake_env,
                            executables,
                            package)
            except Exception:
                logger.error(f"Error processing {cmd}({raw_args}) in "
                             f"{cmake_env['cmakelists'] if 'cmakelists' in cmake_env else 'unknown'}")
                raise
        return CMakeInfo(executables, self._files_generated_by_cmake)

    def __process_aux_source_directory(
            self,
            cmake_env: dict[str, t.Any],
            package: Package,
            raw_args: list[str],
    ) -> None:
        # aux_source_directory(<dir> <var>)
        # Collects the names of all the source files in the specified directory and
        # stores the list in the <variable>
        # https://cmake.org/cmake/help/latest/command/aux_source_directory.html
        var_name = raw_args[1]
        dir_name = Path(raw_args[0])
        path = package.path / cmake_env["cwd"] / dir_name if "cwd" in cmake_env else package.path / dir_name
        values = ";".join(str(dir_name / f) for f in path.glob("*"))
        cmake_env[var_name] = values

    def __process_list_directive(
            self,
            args: list[str],
            cmake_env: dict[str, t.Any],
            opts: dict[str, t.Any],
    ) -> None:
        if not opts["APPEND"]:
            logger.warning(f"Cannot process list({args[0]} ...)")
            return
        append_to = cmake_env[args[0]]
        if not append_to:
            cmake_env[args[0]] = []
            append_to = cmake_env[args[0]]
        if isinstance(append_to, str):
            if append_to:
                append_to += f";{args[1]}"
            else:
                append_to = args[1]
            cmake_env[args[0]] = append_to
        elif isinstance(append_to, list):
            append_to.append(args[1])
        else:
            logger.error(f"Don't know how to append_to append append_to type: {type(append_to)}")

    def __process_file_directive(
            self,
            args: list[str],
            cmake_env: dict[str, t.Any],
            opts: dict[str, t.Any],
            package: Package,
    ) -> None:
        if not opts["GLOB_RECURSE"] and not opts["GLOB"]:
            logger.warning(f"Cannot process file({args[0]} ...")
            return
        path = package.path / cmake_env["cwd"] if "cwd" in cmake_env else package.path
        matches = []
        for arg in args[1:]:
            glob_find = f"/usr/bin/python -c \"import glob; print(glob.glob('{arg}'))\""
            logger.debug(f"Executing find command:  \"{glob_find}\" in '{path}")
            finds_py = self._app_instance.shell.check_output(args=glob_find, cwd=path, text=True)  # TODO Help!
            logger.debug(f"Found {finds_py}")
            finds = [self._trim_and_unquote(f) for f in re.split(r",\|\[|]", finds_py) if f.strip()]
            logger.debug(f"Found the following matches to {arg} in {path}: {finds}")
            matches.extend(finds)
        if opts["RELATIVE"]:
            # convert path to be relative
            relative = package / opts["RELATIVE"]
            matches.extend([str((path / m).relative_to(relative)) for m in matches])
        cmake_env[args[0]] = ";".join(matches)
        logger.debug(f"Set {args[0]} to {cmake_env[args[0]]}")

    def __process_add_subdirectory(
            self,
            args: list[str],
            cmake_env: dict[str, str],
            executables: dict[str, CMakeTarget],
            package: Package,
    ) -> dict[str, CMakeTarget]:
        new_env = cmake_env.copy()
        new_env["cwd"] = str(Path(cmake_env.get("cwd", ".")) / args[0])
        new_env["PROJECT_SOURCE_DIR"] = str(Path(cmake_env.get("CMAKE_SOURCE_DIR", ".")) / args[0])
        new_env["CMAKE_CURRENT_SOURCE_DIR"] = new_env["cwd"]
        cmakelists_path = package.path / new_env["cwd"] / "CMakeLists.txt"
        new_env["cmakelists"] = str(cmakelists_path)
        logger.info(f"Processing {cmakelists_path!s}")
        with cmakelists_path.open() as f:
            contents = f.read()
        included_pacakge_instances = self._process_cmake_contents(contents, package, new_env)
        return {
            **executables,
            **{s: included_pacakge_instances.targets[s] for s in included_pacakge_instances.targets},
        }

    def __process_add_executable(
            self,
            args: list[str],
            cmake_env: dict[str, t.Any],
            executables: dict[str, CMakeTarget],
            package: Package,
    ) -> None:
        name = args[0]
        sources: set[str] = set()
        for source in args[1:]:
            real_src = self._resolve_to_real_file(source, package.path, cmake_env)
            if real_src:
                sources.add(str(real_src))
            else:
                logger.warning(f"'{source} did not resolve to a real file.")
        logger.debug(f"Adding C++ sources for {name}")
        executables[name] = CMakeBinaryTarget(
            name=name,
            language=SourceLanguage.CXX,
            sources=sources,
            restrict_to_paths=self.package_paths(package),
            cmakelists_file=cmake_env["cmakelists"],
            cmakelists_line=cmake_env["cmakelists_line"],
        )

    def __process_add_library(
            self,
            args: list[str],
            cmake_env: dict[str, t.Any],
            executables: dict[str, CMakeTarget],
            package: Package,
    ) -> None:
        name = args[0]
        sources: set[str] = set()
        for source in args[1:]:
            real_src = self._resolve_to_real_file(source, package.path, cmake_env)
            if real_src:
                sources.add(str(real_src))
        logger.debug(f"Adding C++ library {name}")
        executables[name] = CMakeLibraryTarget(
            name,
            SourceLanguage.CXX,
            sources,
            self.package_paths(package),
            cmakelists_file=cmake_env["cmakelists"],
            cmakelists_line=cmake_env["cmakelists_line"],
        )

    def __process_python_executables(
            self,
            args: list[str],
            cmake_env: dict[str, t.Any],
            executables: dict[str, CMakeTarget],
            package: Package,
    ) -> None:
        opts, args = cmake_argparse(
            args,
            {"PROGRAMS": "*", "DESTINATION": "*"},
        )
        if "PROGRAMS" not in opts:
            raise ValueError("PROGRAMS not specifie in catkin_install_python")

        for program in opts["PROGRAMS"]:
            # http://docs.ros.org/en/jade/api/catkin/html/howto/format2/installing_python.html
            # Convention is that ros python nodes are in nodes/ directory.
            # All others are in scripts/. So just include python installs
            # that are in nodes/
            if program.startswith("nodes/"):
                name = Path(program).stem
                sources: set[str] = set()
                source = self._resolve_to_real_file(program, package.path, cmake_env)
                if source:
                    sources.add(str(source))
                logger.debug(f"Adding Python sources for {name}")
                executables[name] = CMakeTarget(name,
                                                SourceLanguage.PYTHON,
                                                sources,
                                                set(),
                                                cmakelists_file=cmake_env["cmakelists"],
                                                cmakelists_line=cmake_env["cmakelists_line"],
                                                )

    def _process_configure_file(
            self,
            cmake_env: dict[str, t.Any],
            rawargs: list[str],
    ) -> None:
        _opts, args = cmake_argparse(rawargs, {"NO_SOURCE_PERMISSIONS": "-",
                                               "USE_SOURCE_PERMISSIONS": "-",
                                               "COPY_ONLY": "-",
                                               "ESCAPE_QUOTES": "-",
                                               "@ONLY": "-",
                                               "NEWLINE_STYLE": "?",
                                               "FILE_PERMISSIONS": "?"})
        # Writing to the container doesn't persist, and so generated sources
        # aren't able to be included. Put this in a list so that we can remember them
        # and not try to resolve them to real files
        if len(args) > 0:
            # Ret rid of the parameter and just use the files
            args = args[1:]
        if len(args) > 0:
            self._files_generated_by_cmake.union(args)
        else:
            # We warn because we ignore generated files
            logger.warning(f"'{cmake_env['cmakelists']}' has no target for 'configure_fle({rawargs})")

    def _trim_and_unquote(self, s: str) -> str:
        s = s.strip()
        is_single_quoted = s.startswith("'") and s.endswith("'")
        is_double_quoted = s.startswith('"') and s.endswith('"')
        if is_single_quoted or is_double_quoted:
            s = s[1:-1]
        return s

    def _resolve_to_real_file(
            self,
            filename: str,
            package: Path,
            cmake_env: dict[str, str],
    ) -> Path | None:
        if filename in self._files_generated_by_cmake:
            return None
        real_filename = Path(filename)
        if "cwd" in cmake_env:
            real_filename = Path(cmake_env["cwd"]) / filename
        if not (package / real_filename).is_file():
            parent = real_filename.parent
            try:
                all_files = (package / parent).glob("*")
                matching_files = [f for f in all_files if str(f).startswith(str(real_filename))]
                if len(matching_files) != 1:
                    raise ValueError(f"Only one file should match '{real_filename!s}'. "
                                     f"Currently {len(matching_files)} files do: {matching_files}")
                real_filename = parent / matching_files[0]
            except ValueError:
                raise
            except Exception:
                logger.error(
                    f"Error finding real file matching {real_filename} "
                    f"in {package / parent!s}")
                logger.error(cmake_env)
                raise
        return real_filename
